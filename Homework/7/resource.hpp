/* You may only include these two header files. */#include <utility>      /* For std::pair. */#include <functional>   /* For std::less. *///#include <iostream>/* You may finally allowed to use // in C++. */#define RAND_HALF ((RAND_MAX) / 2)////// The implementation for skiplist class follows here!//////                S K I P L I S T/////* ==================== Begin students' code ==================== *//* One possible function definition has been filled for you, * you may change it as you wish. */template<class Key, class Val, class Compare>std::pair<typename skiplist<Key, Val, Compare>::iterator, bool> skiplist<Key, Val, Compare>::insert(const Key &key, const Val &val){	_listnode* current = head;	_listnode* pre[max_level];	int count = 0;	//std::cout << "key = " << key << std::endl;	for (int i = max_level; i > 0; i = i - 1) {		//std::cout << "i = " << i << std::endl;		while (current->pointers[i-1] != NULL) {			if (comp(key, current->pointers[i-1]->_data.first)) {				break;			} else {				if (comp(current->pointers[i-1]->_data.first, key)) {					current = current->pointers[i-1];				} else {					current->pointers[i-1]->_data.second = val;					std::pair<typename skiplist<Key, Val, Compare>::iterator, bool> result = std::make_pair(iterator(current->pointers[i-1]), false);					return result;				}			}		}		pre[count] = current;		count = count + 1;	}	//std::cout << "key = " << key << std::endl;	//std::cout << "max_level = " << max_level << std::endl;	_listnode* new_node = new _listnode(key, val, h_limit, 0);	//std::cout << "level = " << new_node->node_level << std::endl;	if (new_node->node_level > max_level) {		max_level = new_node->node_level;	}	for (int i = new_node->node_level - 1; i >= 0; i = i - 1) {		if (i < count) {			new_node->pointers[i] = pre[count-i-1]->pointers[i];			pre[count-i-1]->pointers[i] = new_node;		} else {			head->pointers[i] = new_node;		}	}	max_size = max_size + 1;	std::pair<typename skiplist<Key, Val, Compare>::iterator, bool> result = std::make_pair(iterator(new_node), true);	return result;	// Your code here ...}/* This may seem obscure for beginners, so here's a simple explanation:	- "template<class Key, class Val, class Compare>"		- We need to use template for generic skiplist class.	- "std::pair<typename skiplist<Key, Val, Compare>::iterator, bool>"		- This is the return type of this function, see insert function in skiplist.h.		- "typename skiplist<Key, Val, Compare>::iterator"			- `typename` specifies that the type "skiplist<Key, Val, Compare>" should				have a field called "iterator", and then use it as the type of `first`				for std::pair.		- It is analogy to "std::pair<iterator, bool>" in skiplist.h.	- "skiplist<Key, Val, Compare>::insert(const Key &key, const Val &val)"		- The real function name, refers to the inline declaration in skiplist.h.		- `insert` belongs to type "skiplist<Key, Val, Compare>".	This function may have the most complicated definiton in this file. The	definition for other functions would be more friendly. You should know how	other functions are defined after reading this explanation. */template<class Key,class Val, class Compare>void skiplist<Key, Val, Compare>::Print(){	int i=max_level-1;	while(i>=0)	{		_listnode* cur=head->pointers[i];		printf("this is %d leve:",i+1);		while(cur)		{			std::cout<<cur->_data.first<<":"<<"["<<cur->_data.second<<"]"<<" ";			cur=cur->pointers[i];		}		i--;		printf("\n");	}}template<class Key, class Val, class Compare>typename skiplist<Key, Val, Compare>::iterator skiplist<Key, Val, Compare>::find(const Key &key) {	_listnode* current = head;	for (int i = max_level; i > 0; i = i - 1) {		while (current->pointers[i-1] != NULL) {			if (comp(key, current->pointers[i-1]->_data.first) != 1) {				current = current->pointers[i-1];			} else {				break;			}		}	}	if (comp(current->_data.first, key) != 1 && comp(key, current->_data.first) != 1) {		return iterator(current);	}	return end();}template<class Key, class Val, class Compare>typename skiplist<Key, Val, Compare>::const_iterator skiplist<Key, Val, Compare>::find(const Key &key) const{	_listnode* current = head;	for (int i = max_level; i > 0; i = i - 1) {		while (current->pointers[i-1] != NULL) {			if (Compare(current->pointers[i-1]->key, key)) {				current = current->pointers[i-1];			} else {				break;			}		}	}	if (Compare(current->key, key) && Compare(key, current->key)) {		return begin();	}	return end();}template<class Key, class Val, class Compare>bool skiplist<Key, Val, Compare>::erase(const Key &key) {	int i;	_listnode* current = head;	_listnode* pre[max_level];	int count = 0;	for (i = max_level; i > 0; i = i - 1) {		while (current->pointers[i-1] != NULL) {			if (comp(current->pointers[i-1]->_data.first,key)) {				current = current->pointers[i-1];			} else {				break;			}		}		pre[count] = current;		count = count + 1;	}	if (current->pointers[0] != NULL) {		if (comp(current->pointers[0]->_data.first, key) != 1 && comp(key, current->pointers[0]->_data.first) != 1) {			int cur_level = current->pointers[0]->node_level;			current = current->pointers[0];			_listnode* tmp = current;			for (i = 0; i < cur_level; i = i + 1) {				pre[count-i-1]->pointers[i] = current->pointers[i];				current->pointers[i] = NULL;			}			delete tmp;			max_size = max_size - 1;			return true;		}	}	return false;}/* ==================== End students' code ==================== */////// The implementation for _listnode subclass follows here!//////                L I S T   N O D E/////* ==================== Begin students' code ==================== *//* One possible function definition has been filled for you, * you may change it as you wish. */template<class Key, class Val, class Compare>inline typename skiplist<Key, Val, Compare>::iterator skiplist<Key, Val, Compare>::begin() {	return iterator(head->pointers[0]);}template<class Key, class Val, class Compare>inline typename skiplist<Key, Val, Compare>::iterator skiplist<Key, Val, Compare>::end() {	return iterator();}template<class Key, class Val, class Compare>inline typename skiplist<Key, Val, Compare>::const_iterator skiplist<Key, Val, Compare>::begin() const{	return const_iterator(head->pointers[0]);}template<class Key, class Val, class Compare>inline typename skiplist<Key, Val, Compare>::const_iterator skiplist<Key, Val, Compare>::end() const{	return const_iterator();}template<class Key, class Val, class Compare>bool skiplist<Key, Val, Compare>::empty() const {	if (head->pointers[0] == NULL) {		return true;	} else {		return false;	}}template<class Key, class Val, class Compare>int skiplist<Key, Val, Compare>::size() const {	return max_size;}template<class Key, class Val, class Compare>int skiplist<Key, Val, Compare>::level() const {	return max_level;}template<class Key, class Val, class Compare>skiplist<Key, Val, Compare>::~skiplist() {		_listnode* tmp1 = head;		_listnode* tmp2;		while (tmp1 != NULL) {			tmp2 = tmp1;			tmp1 = tmp1->pointers[0];			delete tmp2;		}		head = NULL;	}template<class Key, class Val, class Compare>skiplist<Key, Val, Compare>::skiplist(int height_limit, Compare cmp) {		head = new _listnode(-1,-1,height_limit,1);		max_level = 1;		max_size = 0;		h_limit = height_limit;		comp = cmp;	};template<class Key, class Val, class Compare>skiplist<Key, Val, Compare>::_listnode::_listnode(const Key &k, const Val &v, int height_limit, int flag):_data(std::make_pair(k, v)) {	if (flag == 0) {		int new_level = 0;		while (new_level < height_limit - 1 && rand() < RAND_HALF) ++new_level;		new_level = new_level + 1;		node_level = new_level;		pointers = new _listnode*[new_level];		for (int i = 0; i < new_level; ++i) {			pointers[i] = NULL;		}	} else {		node_level = height_limit;		pointers = new _listnode*[height_limit];		for (int i = 0; i < height_limit; ++i) {			pointers[i] = NULL;		}	}}template<class Key, class Val, class Compare>skiplist<Key, Val, Compare>::_listnode::~_listnode() { 	delete[] skiplist<Key, Val, Compare>::_listnode::pointers;	/* Your code ... */ }/* Simple explanation:	- The first line is the same template argument as described in the first section.	- "skiplist<Key, Val, Compare>::_listnode::~_listnode()"		- This is the destructor function of _listnode subclass, so it does not			has a return type.		- `~_listnode` is the destructor function name inside class			"skiplist<Key, Val, Compare>::_listnode". *//* ==================== End students' code ==================== */////// The implementation for iterator subclass follows here!//////                I T E R A T O R/////* ==================== Begin students' code ==================== *//* One possible function definition has been filled for you, * you may change it as you wish. */template<class Key, class Val, class Compare>skiplist<Key, Val, Compare>::iterator::iterator(_listnode* ptr) { 	pt = ptr;}template<class Key, class Val, class Compare>skiplist<Key, Val, Compare>::iterator::~iterator() { }template<class Key, class Val, class Compare>typename skiplist<Key, Val, Compare>::iterator&skiplist<Key, Val, Compare>::iterator::operator++() { 	if (pt != NULL) {		pt = pt->pointers[0];	}	return iterator(pt);}template<class Key, class Val, class Compare>typename skiplist<Key, Val, Compare>::iteratorskiplist<Key, Val, Compare>::iterator::operator++(int) { 	iterator tmp = pt;	if (pt != NULL) {		pt = pt->pointers[0];	}	return iterator(tmp);}template<class Key, class Val, class Compare>bool skiplist<Key, Val, Compare>::iterator::operator==(const iterator &other) const {	if (other.pt == pt) {		return true;	} else {		return false;	}}template<class Key, class Val, class Compare>bool skiplist<Key, Val, Compare>::iterator::operator!=(const iterator &other) const {	if (other.pt != pt) {		return true;	} else {		return false;	}}template<class Key, class Val, class Compare>std::pair<const Key, Val>&skiplist<Key, Val, Compare>::iterator::operator*() const { return pt->_data;/* Your code ... */; }template<class Key, class Val, class Compare>std::pair<const Key, Val>*skiplist<Key, Val, Compare>::iterator::operator->() const {	return &(pt->_data);}/* Simple explanation:	- The first line is the same template argument as described in the first section.	- "std::pair<const Key, Val> &"		- The return type of the dereference operator.		- This is not the data pair itself, but a reference to the pair.	- "skiplist<Key, Val, Compare>::iterator::operator*()"		- The dereference funtion, refers to the inline declaration in skiplist.h. *//* ==================== End students' code ==================== */////// The implementation for iterator subclass follows here!//////                C O N S T      I T E R A T O R/////* ==================== Begin students' code ==================== *//* Fill in the const_iterator part, this should be similiar to iterator */template<class Key, class Val, class Compare>skiplist<Key, Val, Compare>::const_iterator::const_iterator(_listnode* ptr) { 	pt = ptr;}template<class Key, class Val, class Compare>skiplist<Key, Val, Compare>::const_iterator::~const_iterator() { }template<class Key, class Val, class Compare>typename skiplist<Key, Val, Compare>::const_iterator&skiplist<Key, Val, Compare>::const_iterator::operator++() { 	if (pt != NULL) {		pt = pt->pointers[0];	}	return iterator(pt);}template<class Key, class Val, class Compare>typename skiplist<Key, Val, Compare>::const_iteratorskiplist<Key, Val, Compare>::const_iterator::operator++(int) { 	iterator tmp = pt;	if (pt != NULL) {		pt = pt->pointers[0];	}	return iterator(tmp);}template<class Key, class Val, class Compare>bool skiplist<Key, Val, Compare>::const_iterator::operator==(const const_iterator &other) const {	if (other.pt == pt) {		return true;	} else {		return false;	}}template<class Key, class Val, class Compare>bool skiplist<Key, Val, Compare>::const_iterator::operator!=(const const_iterator &other) const {	if (other.pt != pt) {		return true;	} else {		return false;	}}template<class Key, class Val, class Compare>std::pair<const Key, Val>&skiplist<Key, Val, Compare>::const_iterator::operator*() const { return pt->_data;/* Your code ... */; }template<class Key, class Val, class Compare>std::pair<const Key, Val>*skiplist<Key, Val, Compare>::const_iterator::operator->() const {	return &(pt->_data);}/* ==================== End students' code ==================== */